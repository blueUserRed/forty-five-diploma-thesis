
\subsection{Warum Onj?}\label{subsec:warum-onj}

\renewcommand{\kapitelautor}{Autor: Marvin Kurka}

Erfahrung, die wir in früheren Projekten \bzw Vorarbeit an \FF gesammelt haben zeigt, dass
es oft kurzfristig zu Änderungen und Anpassen bezüglich des Gameplays kommt.
Oft handelt es sich dabei um komplexere Funktionen, die Mechaniken des Gameplays ändern, oft sind es aber auch nur
simple Balancing-Änderungen, bei denen \zB nur der Schadenswert einer Karte geändert wird.
Daher hatten wir bei \FF den Anspruch, dass solche Balancing-Änderungen schnell und von Leuten mit keiner Kenntnis
des Programmaufbaus vorgenommen werden können.

Bei der Wahl der Markupsprache hatten wir die Wahl zwischen einen bereits etablierten Format wie XML, JSON oder YAML,
oder den selbst entwickelten Format Onj.
Unsere Wahl ist aus mehreren Gründen auf Onj gefallen.

\begin{liste}
    \item Variablen und Imports erhöhen die Maintainability in größeren Projekten
    \item OnjSchemas helfen sicherzustellen, das die Dateien im korrekten Format sind
    \item Onjs Syntax ist leichter zu lesen als \zB der von Json
    \item Namespaces ermöglichen eine gute Integration mit dem Programm
    \item Onjs API ist für Kotlin ausgelegt und verwendet Features der Sprache, wie reified Generics oder
        Lambdas mit Receiver
    \item Dadurch, dass Onj selbst entwickelt wurde, können, falls notwendig, Features hinzugefügt werden (So wurde die
        Sprache \zB während des Projektes um einen Minifier erweitert, um Maps effizienter zu speichern.)
\end{liste}

% resets author
\renewcommand{\kapitelautor}{}
